# SPDX-FileCopyrightText: 2025 hexaTune LLC
# SPDX-License-Identifier: MIT

default_platform(:ios)

# --- Helper methods ----------------------------------------------------------

def repo_root
  # The repository root is one level above the fastlane directory
  File.expand_path("..", __dir__)
end

def resolve_path(p)
  # If APP_DIR is not absolute, resolve it relative to the repository root
  return p if p.start_with?("/")
  File.expand_path(p, repo_root)
end

def detect_app_dir
  # 1) Manual override â€” if APP_DIR is provided via environment variable, use it
  from_env = ENV['APP_DIR']
  if from_env
    candidate = resolve_path(from_env)
    UI.user_error!("APP_DIR='#{from_env}' provided but directory not found: #{candidate}") unless Dir.exist?(candidate)
    return candidate
  end

  # 2) Automatic detection â€” try common Flutter directory names
  candidates = %w[hexagenapp hexaGenApp app .]
  hit = candidates.find do |d|
    full = File.expand_path(d, repo_root)
    File.exist?(File.join(full, "pubspec.yaml"))
  end
  hit ||= candidates.find do |d|
    full = File.expand_path(d, repo_root)
    Dir.exist?(File.join(full, "ios"))
  end

  UI.user_error!("Flutter project directory not found. Tried: #{candidates.join(', ')}") unless hit
  File.expand_path(hit, repo_root)
end

# --- Main lane ---------------------------------------------------------------

platform :ios do
  desc "Build the Flutter IPA and upload it to TestFlight"
  lane :beta do
    # Configure keychain for CI environments (e.g., GitHub Actions)
    setup_ci if ENV['CI']

    app_dir = detect_app_dir
    UI.message("Using Flutter app directory: #{app_dir}")

    Dir.chdir(app_dir) do
      sh("flutter --version")
      sh("flutter pub get")

      # Run CocoaPods if needed (optional â€” Flutter usually manages this)
      if File.directory?("ios") && File.exist?(File.join("ios", "Podfile"))
        Dir.chdir("ios") do
          sh("pod repo update")
          sh("pod install")
        end
      end

      # Build number comes from CI or uses timestamp fallback
      build_number = ENV['BUILD_NUMBER'] || Time.now.strftime("%Y%m%d%H%M")
      sh("flutter build ipa --release --build-number=#{build_number}")
    end

    # Locate the generated IPA
    app_dir = detect_app_dir
    ipa = Dir[File.join(app_dir, "build/ios/ipa/*.ipa")].first
    UI.user_error!("IPA not found at #{File.join(app_dir, 'build/ios/ipa/*.ipa')}") unless ipa

    # Retrieve App Store Connect API key (set by GitHub Actions workflow)
    api_key_path = ENV['APP_STORE_CONNECT_API_KEY_PATH']
    UI.user_error!("APP_STORE_CONNECT_API_KEY_PATH is missing or invalid") unless api_key_path && File.exist?(api_key_path)

    # Upload to TestFlight
    upload_to_testflight(
      ipa: ipa,
      api_key_path: api_key_path,
      skip_waiting_for_build_processing: true,
      notify_external_testers: false,
      groups: []
    )

    UI.success("ðŸŽ‰ TestFlight upload triggered successfully!")
  end
end
